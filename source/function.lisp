(in-package :caten)
;; Function creating a lazy computation node, should start with the prefix !.
;; TODO: Func is a syntax sugar for caten/air, we can reconstruct Func from Graph
(defclass Func () ((variables :initarg :variables :initform nil :accessor func-variables)))

(defgeneric lower (op &rest nodes)
  (:documentation "Lowers the Func into a list of `caten/air:node`. This should return caten/air:graph."))
(defgeneric forward (op &rest tensors)
  (:documentation "Create the type for the Tensor after computation. Be mindful of its lazy evaluation nature; do not perform the actual computation."))
(defgeneric backward (op prev-grad)
  (:documentation "Create the graph for backward of op given prev-grad. Return: `(values input_1.grad input_2.grad ...)`.
save-for-backward is determined automatically, so you do not have to consider about in-place operation."))

(defmethod forward :around ((op Func) &rest tensors)
  (let ((outs (handler-bind
		  ((error
		     #'(lambda (c) (error 'caten-forward-error :op op :inputs tensors :c c))))
		(multiple-value-list (call-next-method)))))
    (setf (func-variables op) tensors)
    (dolist (o outs)
      (assert (tensor-p o) ())
      (setf (tensor-variables o) tensors
	    (tensor-op o) op))
    (apply #'values outs)))
;; ~~ differentiable ops ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defclass Allocate (Func)
  ((buffer :initarg :buffer :type Tensor :accessor alloc-buffer)
   (initial-element :initarg :initial-element :initform nil :accessor alloc-initial-element)))
(defmethod forward ((op Allocate) &rest tensors) (declare (ignore tensors)) (alloc-buffer op))
(defmethod backward ((op Allocate) dout)
  (let ((buff (alloc-buffer op)))
    (when (tensor-requires-grad buff)
      ;; op.grad += buff
      (let ((accumlated (!add (tensor-grad buff) dout :reduce t)))
	(setf (tensor-id accumlated) (tensor-grad-id buff))
	(values accumlated)))))
(defmethod lower ((op Allocate) &rest inputs)
  (declare (ignore inputs))
  (let ((buff (alloc-buffer op))
	(nodes))
    (flet ((->lower (obj) ;; If the shape includes a tensor, it also needs to be lowered
	     (if (or (numberp obj) (symbolp obj)) obj
		 (let ((g (%tensor->aasm obj)))
		   (and (push g nodes) (car (last (graph-nodes g))))))))
      (let ((g
	      (with-context
		(s (map 'list #'->lower (tensor-shape buff)))
		(a (%make-tensor s :dtype (tensor-dtype buff) :order (tensor-order buff) :id (tensor-id buff)))
		(a (when (alloc-initial-element op) (%load a (alloc-initial-element op)))))))
	(push g nodes)
	(apply #'make-graph (apply #'append (map 'list #'graph-nodes (reverse nodes))))))))

(defclass View (Func)
  ((views :initarg :views :type list :accessor view-views)
   (nrnak :initarg :nrank :accessor view-nrank)))
(defmethod backward ((op View) dout)
  (error "not implemented")
  ;; They are independent:
  ;; 1. reduction 2. slice/take 3. reshape 4. permute 5. broadcast
  ;; 5.と2.を同時に行わない仮定が必要
  )
(defmethod lower ((op View) &rest inputs)
  (let ((nrank (view-nrank op))
	(bs (car (func-variables op))))
    (flet ((subseq1p (x frm &optional to) (subseq x (1+ frm) (if to (1+ to)))))
      (with-context
	  (viewed (%view (car inputs)
			 (subseq1p inputs 0 nrank) (subseq1p inputs nrank (* 2 nrank))
			 (subseq1p inputs (* 2 nrank) (* 3 nrank)) (subseq1p inputs (* 3 nrank) (* 4 nrank))
			 (map 'list #'viewrange-broadcast (view-views op))
			 (let ((base-shape (subseq1p inputs (* 4 nrank) (* 5 nrank)))
			       (stride     (subseq1p inputs (* 5 nrank))))
			   (or stride (%stride base-shape (default-permute nrank (tensor-order bs)))))))))))
(defun !view (base &rest subscripts) (make-view-internal base subscripts))
;; !reshape
;; !permute
(defun !contiguous (x)
  (declare (type tensor x))
  (if (tensor-views x)
      (let ((out (make-tensor (tensor-shape x) :dtype (tensor-dtype x) :order (tensor-order x))))
	(!move out x))
      x))

(defclass Reshape (Func)
  ((shape-bf :initarg :shape-bf :accessor reshape-shape-bf)
   (shape-af :initarg :shape-af :accessor reshape-shape-af)
   (order    :initarg :order    :accessor reshape-order)))
(defmethod forward ((op Reshape) &rest tensors)
  (when (and (every #'numberp (reshape-shape-bf op)) (every #'numberp (reshape-shape-af op)))
    (assert (= (apply #'* (reshape-shape-bf op)) (apply #'* (reshape-shape-af op)))
	    ()
	    "Assertion Failed: Cannot reshape from ~a to ~a. The number of total elements should correspond."
	    (reshape-shape-bf op) (reshape-shape-af op)))
  (make-tensor (reshape-shape-af op) :dtype (tensor-dtype (car tensors)) :order (tensor-order (car tensors))))
(defmethod forward :around ((op Reshape) &rest tensors)
  (let ((out-tensor (call-next-method)))
    (setf (tensor-variables out-tensor)
	  (append (list (car tensors))
		  (loop for s in (reshape-shape-af (tensor-op out-tensor))
			collect (if (tensor-p s) s (iconst s))))
	  (func-variables (tensor-op out-tensor)) (tensor-variables out-tensor))
    out-tensor))
(defmethod backward ((op Reshape) prev-grad) (!reshape prev-grad (reshape-shape-bf op)))
(defmethod lower ((op Reshape) &rest nodes)
  (let ((tensor (car (func-variables op))))
    (with-context
      (a (if (null (reshape-shape-bf op))
	     (%move (%make-tensor `(1) :dtype (tensor-dtype tensor) :order (tensor-order tensor)) (car nodes))
	     (if (null (reshape-shape-af op))
		 (%load (%salloc :dtype (tensor-dtype tensor)) (car nodes))
		 (car nodes))))
      (a (when (reshape-shape-af op) (%reshape a (cdr nodes) :order (reshape-order op)))))))
(defun !reshape (x shape)
  (declare (type tensor x) (type list shape))
  (forward (make-instance 'Reshape :shape-bf (tensor-shape x) :shape-af shape :order (tensor-order x)) x))
(defun !uprank (x n)
  (declare (type tensor x) (type (integer 0) n))
  (!reshape x (append (loop for i upfrom 0 below n collect 1) (tensor-shape x))))
;; ~~ binary ops ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defclass Move (Func) nil)
(defmethod forward ((op Move) &rest tensors) (st "A[~] B[~] -> A[~]" (tensors)))
(defmethod backward ((op Move) dout) (values dout dout))
(defmethod lower ((op Move) &rest inputs)
  (multiple-value-bind (a b) (apply #'values inputs)
    (with-context (out (%move a b)))))
(defun !move (a b) (declare (type tensor a b)) (forward (make-instance 'Move) a b))

(defclass Add (Func) ((reduce :initarg :reduce :initform nil :accessor func-reduce)))
(defmethod forward ((op Add) &rest tensors) (st "A[~] B[~] -> A[~]" (tensors)))
(defmethod backward ((op Add) dout) (values dout dout))
(defmethod lower ((op Add) &rest inputs)
  (multiple-value-bind (a b) (apply #'values inputs)
    (with-context (out (%add a b :reduction (func-reduce op))))))

(defclass Mul (Func) ((reduce :initarg :reduce :initform nil :accessor func-reduce)))
(defmethod forward ((op Mul) &rest tensors) (st "A[~] B[~] -> A[~]" (tensors)))
(defmethod backward ((op Mul) dout)
  (multiple-value-bind (x y) (apply #'values (func-variables op))
    (values (!mul y dout) (!mul x dout))))
(defmethod lower ((op Mul) &rest inputs)
  (multiple-value-bind (a b) (apply #'values inputs)
    (with-context (out (%mul a b :reduction (func-reduce op))))))
;; Unary
(defclass Neg (Func) nil)
(defmethod forward ((op Neg) &rest tensors) (st "A[~] -> A[~]" (tensors)))
(defmethod backward ((op Neg) dout) (values (!neg dout)))
(defmethod lower ((op Neg) &rest inputs) (with-context (a (%neg (car inputs)))))

(defclass Recip (Func) nil)
(defmethod forward ((op Recip) &rest tensors) (st "A[~] -> A[~]" (tensors)))
(defmethod backward ((op Recip) dout)
  (let ((ret (!recip (car (func-variables op)))))
    (values (!mul (!mul (!neg dout) ret) ret)))) ;; -dout / x^2
(defmethod lower ((op Recip) &rest inputs) (with-context (a (%recip (car inputs)))))

(defclass Cast (Func)
  ((dtype-frm :initarg :dtype-frm :accessor cast-dtype-frm)
   (dtype-to :initarg :dtype-to   :accessor cast-dtype-to)))
(defmethod forward ((op Cast) &rest tensors) (st "A[~] B[~] -> A[~]" (tensors)))
(defmethod backward ((op Cast) prev-grad) (values prev-grad (!cast prev-grad (cast-dtype-frm op))))
(defmethod lower ((op Cast) &rest inputs) (with-context (a (%cast (first inputs) (second inputs) (cast-dtype-to op)))))
(defun !cast (x dtype &key (out (make-tensor (tensor-shape x) :dtype dtype :order (tensor-order x))))
  (declare (type tensor x out) (type dtype-t dtype))
  (forward (make-instance 'Cast :dtype-frm (tensor-dtype x) :dtype-to dtype) out x))
;; ~~ wrappers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(declaim (ftype (function (Tensor Tensor &key (:reduce boolean)) (values Tensor &optional)) !add !sub !mul !div))
(defun !add (a b &key (reduce nil)) (apply #'forward (make-instance 'Add :reduce reduce) (broadcast-elwise a b)))
(defun !mul (a b &key (reduce nil)) (apply #'forward (make-instance 'Mul :reduce reduce) (broadcast-elwise a b)))
(defun !sub (a b &key (reduce nil)) (!add a (!neg b) :reduce reduce))
(defun !div (a b &key (reduce nil)) (!mul a (!recip b) :reduce reduce))
(macrolet ((def (name b) `(defun ,name (&rest args) (reduce ,b args))))
  (def !+ #'!add)
  (def !- #'!sub)
  (def !* #'!mul)
  (def !/ #'!div))
(macrolet ((def (name cls)
	     `(progn
		(declaim (ftype (function (Tensor) (values Tensor &optional)) ,name))
		(defun ,name (x) (declare (type Tensor x)) (forward (make-instance ',cls) x)))))
  (def !neg Neg)
  (def !recip Recip))
(declaim (ftype (function (Tensor) (values Tensor &optional)) !signum !abs))
(defun !signum (x)
  (flet ((->const (val) (make-scalar val :dtype (tensor-dtype x))))
    (let ((zeros (!where (!eq x (->const 0)) (->const 0) (->const 1))))
      (!mul zeros (!where (!>= x (->const 0)) (->const 1) (->const -1))))))
(defun !abs (x) (!mul (!signum x) x))

;; ~~ Compare Ops ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(macrolet ((def (name cls aop)
	     `(progn
		(defclass ,cls (Func) nil)
		(defmethod forward ((op ,cls) &rest tensors) (st "OUT[~] A[~] B[~] -> OUT[~]" (tensors)))
		(defmethod lower ((op ,cls) &rest inputs)
		  (with-context (out (,aop nil nil (nth 1 inputs) (nth 2 inputs) :out (nth 0 inputs)))))
		(defun ,name (x y)
		  (declare (type Tensor x y))
		  (multiple-value-bind (x y)
		      (bc "A[~] B[~] -> A[~] B[~]" (x y))
		    (forward (make-instance ',cls) (make-tensor (tensor-shape x) :dtype :bool :order (tensor-order x)) x y))))))
  (def !<  LessThan     %<)
  (def !<= LessEqual    %<=)
  (def !>  GreaterThan  %>)
  (def !>= GreaterEqual %>=)
  (def !eq TensorEqual %=)
  (def !neq NotEqual %!=))
;; ~~ TernaryOps ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(defclass Where (Func) nil)
(defmethod forward ((op Where) &rest tensors)
  (assert (eql (tensor-dtype (nth 1 tensors)) (tensor-dtype (nth 2 tensors)))
	  ()
	  "Assertion Failed: A.dtype != B.dtype")
  (st "MAP[~] A[~] B[~] -> A[~]" (tensors)))
(defmethod backward ((op Where) prev-grad)
  (multiple-value-bind (c) (apply #'values (func-variables op))
    (values
     nil
     (!where c prev-grad (zeros-like prev-grad))
     (!where c (zeros-like prev-grad) prev-grad))))
(defmethod lower ((op Where) &rest inputs) (with-context (out (%where (nth 0 inputs) (nth 1 inputs) (nth 2 inputs)))))
(defun !where (condition x y)
  (declare (type Tensor condition x y))
  (multiple-value-bind (condition x y)
      (bc "C[~] X[~] Y[~] -> C[~] X[~] Y[~]" (condition x y))
    (forward (make-instance 'Where) condition x y)))
